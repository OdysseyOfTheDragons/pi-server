#include <assert.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

#include "database.h"

/** Branchless programming to ceil N / M. */
#define CEIL_DIV(N, M) (((N) + (M) - 1) / (M))

/*
 * Implementations details.
 *
 * A database is a single file that is comprised of three sections.
 *
 * ### First section - Header ###
 *
 * The first section is the file header, which contains the neccessary data
 * to parse the file. It includes information like the magic number, the
 * version of the database format, the position of the second and third
 * sections, as well as the maximum number of digits that can be held in this
 * database.
 *
 * This is fixed size.
 *
 * ### Second section - Relocation table ###
 *
 * The second section holds two bitmaps. The first bitmap is whether or not
 * the 16-digit block has been computed. The second bitmap is whether or not
 * the block has been verified.
 *
 * Indeed, to prevent (to some extent) the server or the client spreading
 * false information, I intend to double-check every 16-digit block.
 *
 * The best would be to verify it with two different computers, but to add
 * a random number (unique to every client) to each 16-digit block would add
 * too much of an overhead.
 *
 * This header is fixed size, and each bitmap in itself is of fixed-size, so
 * this is makes it easier to parse. To know whether the n-th 16-digit block
 * has been computed, you only need to look at byte n / 8 and bit n % 8 inside.
 * To know whether a block has been checked, we do the same but with
 * offset the bitmap above.
 *
 * **IMPORTANT** I know my database doesn't have error correction, meaning it
 * is possible to corrupt it quite easily, notably if a writer fails while
 * writing. In order to limit this problem, this relocation header must be the
 * last thing modified before the lock is released. Indeed, when the file is
 * mmap'd in order to grow it, some junk data may appear. But if the relocation
 * table is correct, the database won't read the database that is there.
 * If a writer fails after writing a new block but did not modify the
 * relocation table, it is as if he did nothing. If he first wrote inside the
 * relocation table, then the database may interpret the junk data in the file
 * as valid digits. This would a disaster!
 *
 * ### Third section - Data ###
 *
 * The last section is the heart of the database. The data inside is the digits
 * that were computed.
 *
 * An hexadecimal digit is 4 bits, so we can pack two digits inside a byte.
 * This means a 16-digit block is 8 bytes (wow, it fits perfectly inside a
 * `uint64_t`, what a coincidence!).
 *
 * The blocks are stored linearily, block after block.
 *
 * ### Performance details ###
 *
 * I won't say this implementation is efficient, I am sure there are far better
 * ways to store the digits. But this is the way that came to my mind, and I
 * find it not to be too bad. For instance, for 10 billion digits, I could
 * create from the get-go a 5 GB database, but I would need to parse nearly
 * 4 GB to find not computed blocks (presuming there is at least a bit to
 * indicate whether the block has been computed), which would take time.
 *
 * Here, for 10 billion digits, the data will grow to 5 GB with a relocation
 * table of 157 MB, so quite nothing compared to 5 GB. And I would only need
 * to parse 80 kB to find not computed blocks.
 *
 * For 1 billion digits (my goal), the whole database would be less than
 * 500 MB, when a text file with all the digits (like we found on the internet)
 * is double that.
 */

struct database_t {
	/// The database path, in order to reopen / remap.
	const char *path;

	/// The database file descriptor.
	int fd;

	/// The mmap'd file array.
	uint8_t *map;

	/// The offset to the second section.
	uint64_t offset_rel;

	/// The offset to the third section.
	uint64_t offset_data;

	/// The offset generated by a single bitmap.
	uint64_t offset_bitmap;

	/// The maximum number of digits that can be stored inside the database.
	uint64_t maximum_digits;

	/// The current size of the file.
	uint64_t length;
};

#pragma pack(push, 1)
/** The database header. */
typedef struct {
	/// Database magic number.
	uint8_t magic_number[8];

	/// Database version.
	uint8_t version;

	/// Maximum number of digits.
	uint64_t max_digits;

	/// Offset to the relocation table.
	uint64_t offset_rel;

	/// Offset to the data section.
	uint64_t offset_data;

	/// Padding (reserved for future use).
	uint8_t padding[31];
} header_t;
#pragma pack(pop)

/** The database magic number. */
#define MAGIC_NUMBER "PiDB\x24\x3F\x6A\x88"

/** The database version. */
#define VERSION 1

/** The size of the header. */
#define HEADER_SIZE 64

db_return db_create(const char * const path, const uint64_t max_digits) {
	assert(max_digits > 0);

	FILE* db = fopen(path, "wb");
	if (db == NULL)
		return (db_return){ .errno = DB_OPEN_FAIL };

	// Generate the header to print to the file.
	//
	// To know the size of the relocation table, we have the following:
	// For n digits that can be stored, we have two bitmaps (2 * n).
	// A bit stores 16 digits (2n / 16).
	// A byte is 8 bits (2n / 16 / 8).
	// And we pad it to a full byte using branchless programming:
	// to ceil N / M, we do (N + M - 1) / M.
	uint64_t bitmaps_size = 2 * CEIL_DIV(max_digits, 16 * 8);

	header_t header = {
		.magic_number = MAGIC_NUMBER,
		.version = VERSION,
		.max_digits = max_digits,

		// The header is 64 bytes long.
		.offset_rel = HEADER_SIZE,

		// We compute the relocation table size.
		.offset_data = HEADER_SIZE + bitmaps_size,

		// Empty padding.
		.padding = { 0 },
	};

	// Print the header.
	fwrite(&header, sizeof(header), 1, db);

	// Print an empty bitmap.
	uint8_t bitmaps[bitmaps_size];
	memset(bitmaps, 0, sizeof(bitmaps));
	fwrite(&bitmaps, sizeof(bitmaps), 1, db);

	// We finished creating the database.
	// We flush and close.
	fflush(db);
	fclose(db);

	return (db_return){ .errno = DB_SUCCESS };
}

db_return db_open(const char * const path) {
	// Check if file exists and we have permissions.
	struct stat st;

	if (
			stat(path, &st) != 0
			|| !S_ISREG(st.st_mode)
			|| access(path, F_OK)
			|| access(path, R_OK) != 0
			|| access(path, W_OK) != 0
		) return (db_return){ .errno = DB_OPEN_FAIL };

	// Open the file.
	FILE *file = fopen(path, "wb+");
	if (file == NULL)
		return (db_return){ .errno = DB_OPEN_FAIL };

	// Read the header.
	header_t header;
	if (fread(&header, sizeof(header), 1, file) != 1) {
		fclose(file);
		return (db_return){ .errno = DB_OPEN_FAIL };
	}

	// Verify the magic number and the version.
	if (memcmp(header.magic_number, MAGIC_NUMBER, 8) != 0
			|| header.version != VERSION) {
		fclose(file);
		return (db_return){ .errno = DB_OPEN_FAIL };
	}

	// Once we have the file, we can construct the database.
	database *db = (database *)malloc(sizeof(database));

	db->path = path;
	db->offset_rel = header.offset_rel;
	db->offset_data = header.offset_data;
	db->maximum_digits = header.max_digits;
	db->offset_bitmap = CEIL_DIV(header.max_digits, 16 * 8);
	db->length = st.st_size;

	// We now need to mmap the file to access it.
	int fd = fileno(file);
	db->fd = fd;
	db->map =
		(uint8_t *)mmap(NULL, st.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (db->map == MAP_FAILED) {
		fclose(file);
		return (db_return){ .errno = DB_OPEN_FAIL };
	}

	return (db_return){
		.errno = DB_SUCCESS,
		.value = { .database = db }
	};
}
