#define _GNU_SOURCE

#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

#include "shared.h"
#include "database.h"

/** Branchless programming to ceil N / M. */
#define CEIL_DIV(N, M) (((N) + (M) - 1) / (M))

/*
 * Implementations details.
 *
 * A database is a single file that is comprised of three sections.
 *
 * ### First section - Header ###
 *
 * The first section is the file header, which contains the neccessary data
 * to parse the file. It includes information like the magic number, the
 * version of the database format, the position of the second and third
 * sections, as well as the maximum number of digits that can be held in this
 * database.
 *
 * This is fixed size.
 *
 * ### Second section - Relocation table ###
 *
 * The second section holds two bitmaps. The first bitmap is whether or not
 * the 16-digit block has been computed. The second bitmap is whether or not
 * the block has been verified.
 *
 * Indeed, to prevent (to some extent) the server or the client spreading
 * false information, I intend to double-check every 16-digit block.
 *
 * The best would be to verify it with two different computers, but to add
 * a random number (unique to every client) to each 16-digit block would add
 * too much of an overhead.
 *
 * This header is fixed size, and each bitmap in itself is of fixed-size, so
 * this is makes it easier to parse. To know whether the n-th 16-digit block
 * has been computed, you only need to look at byte n / 8 and bit n % 8 inside.
 * To know whether a block has been checked, we do the same but with
 * offset the bitmap above.
 *
 * **IMPORTANT** I know my database doesn't have error correction, meaning it
 * is possible to corrupt it quite easily, notably if a writer fails while
 * writing. In order to limit this problem, this relocation header must be the
 * last thing modified before the lock is released. Indeed, when the file is
 * mmap'd in order to grow it, some junk data may appear. But if the relocation
 * table is correct, the database won't read the database that is there.
 * If a writer fails after writing a new block but did not modify the
 * relocation table, it is as if he did nothing. If he first wrote inside the
 * relocation table, then the database may interpret the junk data in the file
 * as valid digits. This would a disaster!
 *
 * ### Third section - Data ###
 *
 * The last section is the heart of the database. The data inside is the digits
 * that were computed.
 *
 * An hexadecimal digit is 4 bits, so we can pack two digits inside a byte.
 * This means a 16-digit block is 8 bytes (wow, it fits perfectly inside a
 * `uint64_t`, what a coincidence!).
 *
 * The blocks are stored linearily, block after block.
 *
 * ### Performance details ###
 *
 * I won't say this implementation is efficient, I am sure there are far better
 * ways to store the digits. But this is the way that came to my mind, and I
 * find it not to be too bad. For instance, for 10 billion digits, I could
 * create from the get-go a 5 GB database, but I would need to parse nearly
 * 4 GB to find not computed blocks (presuming there is at least a bit to
 * indicate whether the block has been computed), which would take time.
 *
 * Here, for 10 billion digits, the data will grow to 5 GB with a relocation
 * table of 157 MB, so quite nothing compared to 5 GB. And I would only need
 * to parse 80 kB to find not computed blocks.
 *
 * For 1 billion digits (my goal), the whole database would be less than
 * 500 MB, when a text file with all the digits (like we found on the internet)
 * is double that.
 */

struct database_t {
	/// The database path, in order to reopen / remap.
	const char *path;

	/// The database file descriptor.
	int fd;

	/// The mmap'd file array.
	uint8_t *map;

	/// The offset to the second section.
	uint64_t offset_rel;

	/// The offset to the third section.
	uint64_t offset_data;

	/// The offset generated by a single bitmap.
	uint64_t offset_bitmap;

	/// The maximum number of digits that can be stored inside the database.
	uint64_t maximum_digits;

	/// The current size of the file.
	uint64_t length;
};

#pragma pack(push, 1)
/** The database header. */
typedef struct {
	/// Database magic number.
	uint8_t magic_number[8];

	/// Database version.
	uint8_t version;

	/// Maximum number of digits.
	uint64_t max_digits;

	/// Offset to the relocation table.
	uint64_t offset_rel;

	/// Offset to the data section.
	uint64_t offset_data;

	/// Padding (reserved for future use).
	uint8_t padding[31];
} header_t;
#pragma pack(pop)

/** The database magic number. */
#define MAGIC_NUMBER "PiDB\x24\x3F\x6A\x88"

/** The database version. */
#define VERSION 1

/** The size of the header. */
#define HEADER_SIZE 64

db_return db_create(const char * const path, const uint64_t max_digits) {
	assert(max_digits > 0);

	FILE* db = fopen(path, "wb");
	if (db == NULL)
		return (db_return){ .errno = DB_OPEN_FAIL };

	// Generate the header to print to the file.
	//
	// To know the size of the relocation table, we have the following:
	// For n digits that can be stored, we have two bitmaps (2 * n).
	// A bit stores 16 digits (2n / 16).
	// A byte is 8 bits (2n / 16 / 8).
	// And we pad it to a full byte using branchless programming:
	// to ceil N / M, we do (N + M - 1) / M.
	uint64_t bitmaps_size = 2 * CEIL_DIV(max_digits, BLOCK_SIZE * BYTE);

	header_t header = {
		.magic_number = MAGIC_NUMBER,
		.version = VERSION,
		.max_digits = max_digits,

		// The header is 64 bytes long.
		.offset_rel = HEADER_SIZE,

		// We compute the relocation table size.
		.offset_data = HEADER_SIZE + 2 * bitmaps_size,

		// Empty padding.
		.padding = { 0 },
	};

	// Print the header.
	fwrite(&header, sizeof(header), 1, db);

	// Print an empty bitmap.
	uint8_t bitmaps[bitmaps_size];
	memset(bitmaps, 0, sizeof(bitmaps));
	fwrite(&bitmaps, sizeof(bitmaps), 1, db);
	fwrite(&bitmaps, sizeof(bitmaps), 1, db);

	// We finished creating the database.
	// We flush and close.
	fflush(db);
	fclose(db);

	return (db_return){ .errno = DB_SUCCESS };
}

db_return db_open(const char * const path) {
	// Check if file exists and we have permissions.
	struct stat st;

	if (
			stat(path, &st) != 0
			|| !S_ISREG(st.st_mode)
			|| access(path, F_OK)
			|| access(path, R_OK) != 0
			|| access(path, W_OK) != 0
		) return (db_return){ .errno = DB_OPEN_FAIL };

	// Open the file.
	FILE *file = fopen(path, "rb+");
	if (file == NULL)
		return (db_return){ .errno = DB_OPEN_FAIL };

	// Read the header.
	header_t header;
	if (fread(&header, sizeof(header), 1, file) != 1) {
		fclose(file);
		return (db_return){ .errno = DB_OPEN_FAIL };
	}

	// Verify the magic number and the version.
	if (memcmp(header.magic_number, MAGIC_NUMBER, 8) != 0
			|| header.version != VERSION) {
		fclose(file);
		return (db_return){ .errno = DB_OPEN_WRONG_FORMAT };
	}

	// Once we have the file, we can construct the database.
	database *db = (database *)malloc(sizeof(database));

	db->path = path;
	db->offset_rel = header.offset_rel;
	db->offset_data = header.offset_data;
	db->maximum_digits = header.max_digits;
	db->offset_bitmap = CEIL_DIV(header.max_digits, BLOCK_SIZE * BYTE);
	db->length = st.st_size;

	// We now need to mmap the file to access it.
	int fd = fileno(file);
	db->fd = fd;
	db->map =
		(uint8_t *)mmap(NULL, st.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (db->map == MAP_FAILED) {
		fclose(file);
		return (db_return){ .errno = DB_OPEN_FAIL };
	}

	return (db_return){
		.errno = DB_SUCCESS,
		.value = { .database = db },
	};
}

void db_close(database * const db) {
	munmap(db->map, db->length);
	close(db->fd);
	free(db);
}

/**
 * @brief Reads a position for a block.
 * @param db the database to query
 * @param offset if there is an offset in the relocation table to handle
 * @return the position of a bit not set in the relocation header
 *
 * For the errors, it returns the error DB_READ_OUT_OF_BOUNDS which
 * must be changed to DB_READ_NO_UNCOMPUTED/UNCHECKED by the caller.
 */
static db_return db_read_position(database * const db, const uint64_t offset) {
	// We need to read the bytes from the offset_rel but no more than
	// offset_bitmap. If a byte is no 0xFF, it means there is at least a
	// 0 and we get it.
	for (uint64_t k = 0; k < db->offset_bitmap; ++k) {
		if (db->map[db->offset_rel + offset + k] == 0xFF)
			continue;

		// We parsed k bytes, meaning k * 8 16-digit blocks.
		// Now we need to know which one inside the current 8 bits is null.
		const uint8_t byte = db->map[db->offset_rel + offset + k];
		for (uint8_t shift = BYTE; shift > 0; --shift) {
			const uint8_t bit = byte >> (shift - 1);
			if ((bit & 1) == 0) {
				// We got the position (8 - shift) of the bit inside the byte.
				return (db_return){
					.errno = DB_SUCCESS,
					.value = { .position = BYTE * k + (BYTE - shift) },
				};
			}
		}

		// We aren't supposed to get out, because if the byte is not
		// all 1, there is at least a 0.
	}

	// We came out, meaning we computed or checked every block.
	return (db_return){ .errno = DB_READ_OUT_OF_BOUNDS };
}


db_return db_read_uncomputed(database * const db) {
	db_return ret = db_read_position(db, 0);

	if (ret.errno == DB_SUCCESS)
		return ret;

	return (db_return){ .errno = DB_READ_NO_UNCOMPUTED };
}

db_return db_read_unchecked(database * const db) {
	db_return ret = db_read_position(db, db->offset_bitmap);

	if (ret.errno == DB_SUCCESS)
		return ret;

	return (db_return){ .errno = DB_READ_NO_UNCHECKED };
}

/**
 * @brief Reads a computed/checked flag.
 * @param db the database to query
 * @param position the position of the block to query
 * @param offset an optional offset inside the relocation table
 * @return whether the block at position has its flag set
 */
static db_return db_read_flag(database * const db, const uint64_t position, const uint64_t offset) {
	if (position >= db->maximum_digits)
		return (db_return){ .errno = DB_READ_OUT_OF_BOUNDS };

	// We first fetch the byte where the block flag is set.
	const uint8_t byte = db->map[db->offset_rel + offset + position / BYTE];

	// We then query the flag.
	const uint8_t shift = BYTE - (position % BYTE) - 1;
	const bool is_set = (byte >> shift) & 1;

	return (db_return){
		.errno = DB_SUCCESS,
		.value = { .boolean = is_set },
	};
}


inline db_return db_read_is_computed(database * const db, const uint64_t position) {
	return db_read_flag(db, position, 0);
}

inline db_return db_read_is_checked(database * const db, const uint64_t position) {
	return db_read_flag(db, position, db->offset_bitmap);
}

db_return db_read(database * const db, const uint64_t position) {
	db_return is_computed = db_read_is_computed(db, position);
	if (is_computed.errno != DB_SUCCESS)
		return is_computed;

	if (is_computed.value.boolean != true)
		return (db_return){ .errno = DB_READ_NOT_READY };

	// We store the block inside a uint64_t.
	uint64_t block = 0;
	for (uint8_t k = 0; k < BYTE; ++k) {
		// A 16-byte block fits inside 8 bytes.
		// So our position must be multiplied by 8.
		const uint8_t byte = db->map[db->offset_data + BYTE * position + k];
		block = (block << BYTE) | byte;
	}

	return (db_return){
		.errno = DB_SUCCESS,
		.value = { .block = block },
	};
}

/**
 * @brief Writes a computed/checked flag.
 * @param db the database to query
 * @param position the position of the block to write
 * @param offset an optional offset inside the relocation table
 */
static db_return db_write_flag(database * const db, const uint64_t position, const uint64_t offset) {
	if (position >= db->maximum_digits)
		return (db_return){ .errno = DB_WRITE_OUT_OF_BOUNDS };

	// The shift to set the bit.
	const uint8_t shift = BYTE - (position % BYTE) - 1;

	// We set the flag inside the byte.
	db->map[db->offset_rel + offset + position / BYTE] |= 1 << shift;

	return (db_return){ .errno = DB_SUCCESS };
}

/**
 * @brief Resizes the data portion of the database to be bigger
 * @param db the database to grow
 * @param size the new size of the file
 * @return whether the migration succeeded
 */
static inline db_return db_resize(database * const db, const uint64_t size) {
	if (size < db->length)
		return (db_return){ .errno = DB_MIGRATE_FAIL };

	if (ftruncate(db->fd, size) == -1)
		return (db_return){ .errno = DB_MIGRATE_FAIL };

	uint8_t *map = (uint8_t *)mremap(db->map, db->length, size, MREMAP_MAYMOVE);
	if (map == MAP_FAILED)
		return (db_return){ .errno = DB_MIGRATE_FAIL };

	db->map = map;
	db->length = size;

	return (db_return){ .errno = DB_SUCCESS };
}

db_return db_write_computed(database * const db, const uint64_t position, const uint64_t digits) {
	db_return is_computed = db_read_is_computed(db, position);
	if (is_computed.errno != DB_SUCCESS)
		return is_computed;

	if (is_computed.value.boolean != false)
		return (db_return){ .errno = DB_WRITE_ALREADY_COMPUTED };

	// If the file is too short, we need to extend it.
	// Because this manipulates the intrinsics of the database object,
	// we will need to implement a mutex lock.
	const uint8_t block_length = BLOCK_SIZE / 2;
	const uint64_t size = db->offset_data + position / 2 + block_length;
	if (size >= db->length) {
		db_return resize = db_resize(db, size);
		if (resize.errno != DB_SUCCESS)
			return resize;
	}

	// We then write the block.
	printf("#2 Writing %lx\n", digits);
	for (uint8_t shift = BYTE; shift > 0; --shift) {
		const uint8_t digit = digits >> ((shift - 1) * BYTE);
		printf("#1 Write %x at %ld for %ld\n", digit, db->offset_data + position / 2 + BYTE - shift, position);
		db->map[db->offset_data + position / 2 + BYTE - shift] = digit;
	}
	
	// We then write the flag.
	db_return set_flag = db_write_flag(db, position, 0);

	return set_flag;
}

db_return db_write_checked(database * const db, const uint64_t position) {
	db_return is_checked = db_read_is_checked(db, position);
	if (is_checked.errno != DB_SUCCESS)
		return is_checked;

	if (is_checked.value.boolean != false)
		return (db_return){ .errno = DB_WRITE_ALREADY_CHECKED };

	// We write the flag.
	return db_write_flag(db, position, db->offset_bitmap);
}
