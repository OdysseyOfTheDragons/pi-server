#include <stdio.h>

#include "database.h"

/*
 * Implementations details.
 *
 * A database is a single file that is comprised of three sections.
 *
 * ### First section - Header ###
 *
 * The first section is the file header, which contains the neccessary data
 * to parse the file. It includes information like the magic number, the
 * version of the database format, the position of the second and third
 * sections, as well as the maximum number of digits that can be held in this
 * database.
 *
 * This is fixed size.
 *
 * ### Second section - Relocation table ###
 *
 * The second section holds two bitmaps. The first bitmap is whether or not
 * the 16-digit block has been computed. The second bitmap is whether or not
 * the block has been verified.
 *
 * Indeed, to prevent (to some extent) the server or the client spreading
 * false information, I intend to double-check every 16-digit block.
 *
 * The best would be to verify it with two different computers, but to add
 * a random number (unique to every client) to each 16-digit block would add
 * too much of an overhead.
 *
 * This header is fixed size, and each bitmap in itself is of fixed-size, so
 * this is makes it easier to parse. To know whether the n-th 16-digit block
 * has been computed, you only need to look at byte n / 8 and bit n % 8 inside.
 * To know whether a block has been checked, we do the same but with
 * offset the bitmap above.
 *
 * **IMPORTANT** I know my database doesn't have error correction, meaning it
 * is possible to corrupt it quite easily, notably if a writer fails while
 * writing. In order to limit this problem, this relocation header must be the
 * last thing modified before the lock is released. Indeed, when the file is
 * mmap'd in order to grow it, some junk data may appear. But if the relocation
 * table is correct, the database won't read the database that is there.
 * If a writer fails after writing a new block but did not modify the
 * relocation table, it is as if he did nothing. If he first wrote inside the
 * relocation table, then the database may interpret the junk data in the file
 * as valid digits. This would a disaster!
 *
 * ### Third section - Data ###
 *
 * The last section is the heart of the database. The data inside is the digits
 * that were computed.
 *
 * An hexadecimal digit is 4 bits, so we can pack two digits inside a byte.
 * This means a 16-digit block is 8 bytes (wow, it fits perfectly inside a
 * `uint64_t`, what a coincidence!).
 *
 * The blocks are stored linearily, block after block.
 *
 * ### Performance details ###
 *
 * I won't say this implementation is efficient, I am sure there are far better
 * ways to store the digits. But this is the way that came to my mind, and I
 * find it not to be too bad. For instance, for 10 billion digits, I could
 * create from the get-go a 5 GB database, but I would need to parse nearly
 * 4 GB to find not computed blocks (presuming there is at least a bit to
 * indicate whether the block has been computed), which would take time.
 *
 * Here, for 10 billion digits, the data will grow to 5 GB with a relocation
 * table of 157 MB, so quite nothing compared to 5 GB. And I would only need
 * to parse 80 kB to find not computed blocks.
 *
 * For 1 billion digits (my goal), the whole database would be less than
 * 500 MB, when a text file with all the digits (like we found on the internet)
 * is double that.
 */

struct database_t {
	/// The database path, in order to reopen / remap.
	char *path;

	/// The database file descriptor.
	FILE *db;

	/// The mmap'd file array.
	uint8_t *map;

	/// The offset to the second section.
	uint64_t offset_rel;

	/// The offset to the third section.
	uint64_t offset_data;

	/// The offset generated by a single bitmap.
	uint64_t offset_bitmap;

	/// The maximum number of digits that can be stored inside the database.
	uint64_t maximum_digits;

	/// The current size of the file.
	uint64_t length;
};

/** The database header. */
struct header {
	/// Database magic number.
	uint8_t magic_number[8];

	/// Database version.
	uint8_t version;

	/// Maximum number of digits.
	uint64_t max_digits;

	/// Offset to the relocation table.
	uint64_t offset_rel;

	/// Offset to the data section.
	uint64_t offset_data;
};

/** The database magic number. */
#define MAGIC_NUMBER "PiDB\x24\x3F\x6A\x88"

/** The database version. */
#define VERSION 1
